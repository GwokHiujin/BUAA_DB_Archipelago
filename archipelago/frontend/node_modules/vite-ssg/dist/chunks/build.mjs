import { join, isAbsolute, parse, dirname } from 'path';
import { createRequire } from 'module';
import PQueue from 'p-queue';
import { gray, yellow, blue, dim, cyan, red, green } from 'kolorist';
import fs from 'fs-extra';
import { resolveConfig, build as build$1, mergeConfig } from 'vite';
import { JSDOM } from 'jsdom';
import { s as serializeState } from './state.mjs';

function renderPreloadLinks(document, modules, ssrManifest) {
  const seen = /* @__PURE__ */ new Set();
  const preloadLinks = [];
  Array.from(modules).forEach((id) => {
    const files = ssrManifest[id] || [];
    files.forEach((file) => {
      if (!preloadLinks.includes(file))
        preloadLinks.push(file);
    });
  });
  if (preloadLinks) {
    preloadLinks.forEach((file) => {
      if (!seen.has(file)) {
        seen.add(file);
        renderPreloadLink(document, file);
      }
    });
  }
}
function renderPreloadLink(document, file) {
  if (file.endsWith(".js")) {
    appendLink(document, {
      rel: "modulepreload",
      crossOrigin: "",
      href: file
    });
  } else if (file.endsWith(".css")) {
    appendLink(document, {
      rel: "stylesheet",
      href: file
    });
  }
}
const createLink = (document) => document.createElement("link");
const setAttrs = (el, attrs) => {
  const keys = Object.keys(attrs);
  for (const key of keys)
    el.setAttribute(key, attrs[key]);
};
function appendLink(document, attrs) {
  const exits = document.head.querySelector(`link[href='${attrs.file}']`);
  if (exits)
    return;
  const link = createLink(document);
  setAttrs(link, attrs);
  document.head.appendChild(link);
}

function buildLog(text, count) {
  console.log(`
${gray("[vite-ssg]")} ${yellow(text)}${count ? blue(` (${count})`) : ""}`);
}
function getSize(str) {
  return `${(str.length / 1024).toFixed(2)} KiB`;
}
function routesToPaths(routes) {
  if (!routes)
    return ["/"];
  const paths = /* @__PURE__ */ new Set();
  const getPaths = (routes2, prefix = "") => {
    prefix = prefix.replace(/\/$/g, "");
    for (const route of routes2) {
      let path = route.path;
      if (route.path) {
        path = prefix && !route.path.startsWith("/") ? `${prefix}/${route.path}` : route.path;
        paths.add(path);
      }
      if (Array.isArray(route.children))
        getPaths(route.children, path);
    }
  };
  getPaths(routes);
  return [...paths];
}

async function getCritters(outDir, options = {}) {
  try {
    const CrittersClass = (await import('critters')).default;
    return new CrittersClass({
      path: outDir,
      logLevel: "warn",
      external: true,
      inlineFonts: true,
      preloadFonts: true,
      ...options
    });
  } catch (e) {
    return void 0;
  }
}

function DefaultIncludedRoutes(paths, routes) {
  return paths.filter((i) => !i.includes(":") && !i.includes("*"));
}
async function build(cliOptions = {}, viteConfig = {}) {
  const mode = process.env.MODE || process.env.NODE_ENV || cliOptions.mode || "production";
  const config = await resolveConfig(viteConfig, "build", mode);
  const cwd = process.cwd();
  const root = config.root || cwd;
  const ssgOut = join(root, ".vite-ssg-temp");
  const outDir = config.build.outDir || "dist";
  const out = isAbsolute(outDir) ? outDir : join(root, outDir);
  const {
    script = "sync",
    mock = false,
    entry = await detectEntry(root),
    formatting = "none",
    crittersOptions = {},
    includedRoutes: configIncludedRoutes = DefaultIncludedRoutes,
    onBeforePageRender,
    onPageRendered,
    onFinished,
    dirStyle = "flat",
    includeAllRoutes = false,
    format = "esm",
    concurrency = 20,
    rootContainerId = "app"
  } = Object.assign({}, config.ssgOptions || {}, cliOptions);
  if (fs.existsSync(ssgOut))
    await fs.remove(ssgOut);
  buildLog("Build for client...");
  await build$1(mergeConfig(viteConfig, {
    build: {
      ssrManifest: true,
      rollupOptions: {
        input: {
          app: join(root, "./index.html")
        }
      }
    },
    mode: config.mode
  }));
  if (mock) {
    const { jsdomGlobal } = await import('./jsdomGlobal.mjs');
    jsdomGlobal();
  }
  buildLog("Build for server...");
  process.env.VITE_SSG = "true";
  const ssrEntry = await resolveAlias(config, entry);
  await build$1(mergeConfig(viteConfig, {
    build: {
      ssr: ssrEntry,
      outDir: ssgOut,
      minify: false,
      cssCodeSplit: false,
      rollupOptions: {
        output: format === "esm" ? {
          entryFileNames: "[name].mjs",
          format: "esm"
        } : {
          entryFileNames: "[name].cjs",
          format: "cjs"
        }
      }
    },
    mode: config.mode
  }));
  const prefix = format === "esm" && process.platform === "win32" ? "file://" : "";
  const ext = format === "esm" ? ".mjs" : ".cjs";
  const serverEntry = join(prefix, ssgOut, parse(ssrEntry).name + ext);
  const _require = createRequire(import.meta.url);
  const { createApp, includedRoutes: serverEntryIncludedRoutes } = format === "esm" ? await import(serverEntry) : _require(serverEntry);
  const includedRoutes = serverEntryIncludedRoutes || configIncludedRoutes;
  const { routes } = await createApp(false);
  let routesPaths = includeAllRoutes ? routesToPaths(routes) : await includedRoutes(routesToPaths(routes), routes || []);
  routesPaths = Array.from(new Set(routesPaths));
  buildLog("Rendering Pages...", routesPaths.length);
  const critters = crittersOptions !== false ? await getCritters(outDir, crittersOptions) : void 0;
  if (critters)
    console.log(`${gray("[vite-ssg]")} ${blue("Critical CSS generation enabled via `critters`")}`);
  const ssrManifest = JSON.parse(await fs.readFile(join(out, "ssr-manifest.json"), "utf-8"));
  let indexHTML = await fs.readFile(join(out, "index.html"), "utf-8");
  indexHTML = rewriteScripts(indexHTML, script);
  const { renderToString } = await import('vue/server-renderer');
  const queue = new PQueue.default({ concurrency });
  for (const route of routesPaths) {
    queue.add(async () => {
      try {
        const appCtx = await createApp(false, route);
        const { app, router, head, initialState, triggerOnSSRAppRendered, transformState = serializeState } = appCtx;
        if (router) {
          await router.push(route);
          await router.isReady();
        }
        const transformedIndexHTML = await onBeforePageRender?.(route, indexHTML, appCtx) || indexHTML;
        const ctx = {};
        const appHTML = await renderToString(app, ctx);
        await triggerOnSSRAppRendered?.(route, appHTML, appCtx);
        const renderedHTML = await renderHTML({
          rootContainerId,
          indexHTML: transformedIndexHTML,
          appHTML,
          initialState: transformState(initialState)
        });
        const jsdom = new JSDOM(renderedHTML);
        renderPreloadLinks(jsdom.window.document, ctx.modules || /* @__PURE__ */ new Set(), ssrManifest);
        head?.updateDOM(jsdom.window.document);
        const html = jsdom.serialize();
        let transformed = await onPageRendered?.(route, html, appCtx) || html;
        if (critters)
          transformed = await critters.process(transformed);
        const formatted = await formatHtml(transformed, formatting);
        const relativeRouteFile = `${(route.endsWith("/") ? `${route}index` : route).replace(/^\//g, "")}.html`;
        const filename = dirStyle === "nested" ? join(route.replace(/^\//g, ""), "index.html") : relativeRouteFile;
        await fs.ensureDir(join(out, dirname(filename)));
        await fs.writeFile(join(out, filename), formatted, "utf-8");
        config.logger.info(`${dim(`${outDir}/`)}${cyan(filename.padEnd(15, " "))}  ${dim(getSize(formatted))}`);
      } catch (err) {
        throw new Error(`${gray("[vite-ssg]")} ${red(`Error on page: ${cyan(route)}`)}
${err.stack}`);
      }
    });
  }
  await queue.start().onIdle();
  await fs.remove(ssgOut);
  const pwaPlugin = config.plugins.find((i) => i.name === "vite-plugin-pwa")?.api;
  if (pwaPlugin && !pwaPlugin.disabled && pwaPlugin.generateSW) {
    buildLog("Regenerate PWA...");
    await pwaPlugin.generateSW();
  }
  console.log(`
${gray("[vite-ssg]")} ${green("Build finished.")}`);
  await onFinished?.();
  const waitInSeconds = 15;
  const timeout = setTimeout(() => {
    console.log(`${gray("[vite-ssg]")} ${yellow(`Build process still running after ${waitInSeconds}s. There might be something misconfigured in your setup. Force exit.`)}`);
    process.exit(0);
  }, waitInSeconds * 1e3);
  timeout.unref();
}
async function detectEntry(root) {
  const scriptSrcReg = /<script(?:.*?)src=["'](.+?)["'](?!<)(?:.*)\>(?:[\n\r\s]*?)(?:<\/script>)/img;
  const html = await fs.readFile(join(root, "index.html"), "utf-8");
  const scripts = [...html.matchAll(scriptSrcReg)];
  const [, entry] = scripts.find((matchResult) => {
    const [script] = matchResult;
    const [, scriptType] = script.match(/.*\stype=(?:'|")?([^>'"\s]+)/i) || [];
    return scriptType === "module";
  }) || [];
  return entry || "src/main.ts";
}
async function resolveAlias(config, entry) {
  const resolver = config.createResolver();
  const result = await resolver(entry, config.root);
  return result || join(config.root, entry);
}
function rewriteScripts(indexHTML, mode) {
  if (!mode || mode === "sync")
    return indexHTML;
  return indexHTML.replace(/<script type="module" /g, `<script type="module" ${mode} `);
}
async function renderHTML({
  rootContainerId,
  indexHTML,
  appHTML,
  initialState
}) {
  const stateScript = initialState ? `
<script>window.__INITIAL_STATE__=${initialState}<\/script>` : "";
  const container = `<div id="${rootContainerId}"></div>`;
  if (indexHTML.includes(container)) {
    return indexHTML.replace(container, `<div id="${rootContainerId}" data-server-rendered="true">${appHTML}</div>${stateScript}`);
  }
  const html5Parser = await import('html5parser');
  const ast = html5Parser.parse(indexHTML);
  let renderedOutput;
  html5Parser.walk(ast, {
    enter: (node) => {
      if (!renderedOutput && node?.type === html5Parser.SyntaxKind.Tag && Array.isArray(node.attributes) && node.attributes.length > 0 && node.attributes.some((attr) => attr.name.value === "id" && attr.value?.value === rootContainerId)) {
        const attributesStringified = [...node.attributes.map(({ name: { value: name }, value }) => `${name}="${value.value}"`)].join(" ");
        const indexHTMLBefore = indexHTML.slice(0, node.start);
        const indexHTMLAfter = indexHTML.slice(node.end);
        renderedOutput = `${indexHTMLBefore}<${node.name} ${attributesStringified} data-server-rendered="true">${appHTML}</${node.name}>${stateScript}${indexHTMLAfter}`;
      }
    }
  });
  if (!renderedOutput)
    throw new Error(`Could not find a tag with id="${rootContainerId}" to replace it with server-side rendered HTML`);
  return renderedOutput;
}
async function formatHtml(html, formatting) {
  if (formatting === "minify") {
    const htmlMinifier = await import('html-minifier');
    return htmlMinifier.minify(html, {
      collapseWhitespace: true,
      caseSensitive: true,
      collapseInlineTagWhitespace: false,
      minifyJS: true,
      minifyCSS: true
    });
  } else if (formatting === "prettify") {
    const prettier = (await import('prettier/esm/standalone.mjs')).default;
    const parserHTML = (await import('prettier/esm/parser-html.mjs')).default;
    return prettier.format(html, { semi: false, parser: "html", plugins: [parserHTML] });
  }
  return html;
}

export { build as b };
