import { warnOnce } from '@unocss/core';
import { loadIcon as loadIcon$1 } from '@iconify/utils';
import { encodeSvgForCss } from '@iconify/utils/lib/svg/encode-svg-for-css';
import { loadIcon } from '@iconify/utils/lib/loader/loader';
import { searchForIcon } from '@iconify/utils/lib/loader/modern';
import { $fetch } from 'ohmyfetch';

const isNode = typeof process < "u" && typeof process.stdout < "u" && !process.versions.deno;
const isVSCode = isNode && !!process.env.VSCODE_CWD;

const supportedCollection = ["material-symbols", "ic", "mdi", "ph", "ri", "carbon", "bi", "tabler", "ion", "uil", "teenyicons", "clarity", "iconoir", "majesticons", "zondicons", "ant-design", "bx", "bxs", "gg", "cil", "lucide", "pixelarticons", "system-uicons", "ci", "akar-icons", "typcn", "radix-icons", "ep", "mdi-light", "fe", "eos-icons", "line-md", "charm", "prime", "heroicons-outline", "heroicons-solid", "uiw", "uim", "uit", "uis", "maki", "gridicons", "mi", "quill", "gala", "fluent", "icon-park-outline", "icon-park", "vscode-icons", "jam", "codicon", "pepicons", "bytesize", "ei", "fa6-solid", "fa6-regular", "octicon", "ooui", "nimbus", "openmoji", "twemoji", "noto", "noto-v1", "emojione", "emojione-monotone", "emojione-v1", "fxemoji", "bxl", "logos", "simple-icons", "cib", "fa6-brands", "arcticons", "file-icons", "brandico", "entypo-social", "cryptocurrency", "flag", "circle-flags", "flagpack", "cif", "gis", "map", "geo", "fad", "academicons", "wi", "healthicons", "medical-icon", "la", "eva", "dashicons", "flat-color-icons", "entypo", "foundation", "raphael", "icons8", "iwwa", "fa-solid", "fa-regular", "fa-brands", "fa", "fontisto", "icomoon-free", "ps", "subway", "oi", "wpf", "simple-line-icons", "et", "el", "vaadin", "grommet-icons", "whh", "si-glyph", "zmdi", "ls", "bpmn", "flat-ui", "vs", "topcoat", "il", "websymbol", "fontelico", "feather", "mono-icons"];
function createCDNLoader(cdnBase) {
  const cache = /* @__PURE__ */ new Map();
  function fetchCollection(name) {
    if (!supportedCollection.includes(name))
      return void 0;
    if (!cache.has(name))
      cache.set(name, $fetch(`${cdnBase}@iconify-json/${name}/icons.json`));
    return cache.get(name);
  }
  return async (collection, icon, options) => {
    let result = await loadIcon(collection, icon, options);
    if (result)
      return result;
    const iconSet = await fetchCollection(collection);
    if (iconSet) {
      const ids = [
        icon,
        icon.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(),
        icon.replace(/([a-z])(\d+)/g, "$1-$2")
      ];
      result = await searchForIcon(iconSet, collection, ids, options);
    }
    return result;
  };
}

const COLLECTION_NAME_PARTS_MAX = 3;
const preset = (options = {}) => {
  const {
    scale = 1,
    mode = "auto",
    prefix = "i-",
    warn = false,
    collections: customCollections,
    extraProperties = {},
    customizations = {},
    autoInstall = false,
    layer = "icons",
    unit,
    cdn
  } = options;
  const loaderOptions = {
    addXmlNs: true,
    scale,
    customCollections,
    autoInstall,
    warn: void 0,
    customizations: {
      ...customizations,
      additionalProps: { ...extraProperties },
      trimCustomSvg: true,
      async iconCustomizer(collection, icon, props) {
        await customizations.iconCustomizer?.(collection, icon, props);
        if (unit) {
          if (!props.width)
            props.width = `${scale}${unit}`;
          if (!props.height)
            props.height = `${scale}${unit}`;
        }
      }
    }
  };
  async function lookupIconLoader() {
    if (cdn)
      return createCDNLoader(cdn);
    if (isNode && !isVSCode) {
      try {
        return await import('@iconify/utils/lib/loader/node-loader').then((i) => i?.loadNodeIcon);
      } catch {
      }
      try {
        return require("@iconify/utils/lib/loader/node-loader.cjs");
      } catch {
      }
    }
    return loadIcon$1;
  }
  let iconLoader;
  return {
    name: "@unocss/preset-icons",
    enforce: "pre",
    options,
    layers: {
      icons: -10
    },
    rules: [[
      new RegExp(`^${prefix}([a-z0-9:-]+)(?:\\?(mask|bg|auto))?$`),
      async ([full, body, _mode = mode]) => {
        let collection = "";
        let name = "";
        let svg;
        iconLoader = iconLoader || await lookupIconLoader();
        const usedProps = {};
        if (body.includes(":")) {
          [collection, name] = body.split(":");
          svg = await iconLoader(collection, name, { ...loaderOptions, usedProps });
        } else {
          const parts = body.split(/-/g);
          for (let i = COLLECTION_NAME_PARTS_MAX; i >= 1; i--) {
            collection = parts.slice(0, i).join("-");
            name = parts.slice(i).join("-");
            svg = await iconLoader(collection, name, { ...loaderOptions, usedProps });
            if (svg)
              break;
          }
        }
        if (!svg) {
          if (warn)
            warnOnce(`failed to load icon "${full}"`);
          return;
        }
        const url = `url("data:image/svg+xml;utf8,${encodeSvgForCss(svg)}")`;
        if (_mode === "auto")
          _mode = svg.includes("currentColor") ? "mask" : "bg";
        if (_mode === "mask") {
          return {
            "--un-icon": url,
            "mask": "var(--un-icon) no-repeat",
            "mask-size": "100% 100%",
            "-webkit-mask": "var(--un-icon) no-repeat",
            "-webkit-mask-size": "100% 100%",
            "background-color": "currentColor",
            ...usedProps
          };
        } else {
          return {
            "background": `${url} no-repeat`,
            "background-size": "100% 100%",
            "background-color": "transparent",
            ...usedProps
          };
        }
      },
      { layer }
    ]]
  };
};

export { preset as default, preset };
