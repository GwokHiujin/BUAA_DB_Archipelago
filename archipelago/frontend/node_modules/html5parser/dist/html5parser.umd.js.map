{"version":3,"file":"html5parser.umd.js","sources":["../src/types.ts","../src/tokenize.ts","../src/config.ts","../src/parse.ts","../src/walk.ts","../src/utils.ts","../src/safeHtml.ts"],"sourcesContent":["/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-18 15:17:51\n * @version 1.0.0\n * @desc types.ts\n */\n\nexport enum SyntaxKind {\n  Text = 'Text',\n  Tag = 'Tag',\n}\n\nexport interface IBaseNode {\n  start: number;\n  end: number;\n}\n\nexport interface IText extends IBaseNode {\n  type: SyntaxKind.Text;\n  value: string;\n}\n\nexport interface IAttributeValue extends IBaseNode {\n  value: string;\n  quote: \"'\" | '\"' | undefined;\n}\n\nexport interface IAttribute extends IBaseNode {\n  name: IText;\n  value: IAttributeValue | undefined;\n}\n\nexport interface ITag extends IBaseNode {\n  type: SyntaxKind.Tag;\n  // original open tag, <Div id=\"id\">\n  open: IText;\n  // lower case tag name, div\n  name: string;\n  // original case tag name, Div\n  rawName: string;\n  attributes: IAttribute[];\n  // the attribute map, if `options.setAttributeMap` is `true`\n  // this will be a Record, key is the attribute name literal,\n  // value is the attribute self.\n  attributeMap: Record<string, IAttribute> | undefined;\n  body:\n    | Array<ITag | IText> // with close tag\n    | undefined // self closed\n    | null; // EOF before open tag end\n  // original close tag, </DIV >\n  close:\n    | IText // with close tag\n    | undefined // self closed\n    | null; // EOF before end or without close tag\n}\n\nexport type INode = IText | ITag;\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:29\n * @version 1.0.0\n * @desc tokenize.ts\n */\n\nconst enum State {\n  Literal,\n  BeforeOpenTag,\n  OpeningTag,\n  AfterOpenTag,\n  InValueNq,\n  InValueSq,\n  InValueDq,\n  ClosingOpenTag,\n  OpeningSpecial,\n  OpeningDoctype,\n  OpeningNormalComment,\n  InNormalComment,\n  InShortComment,\n  ClosingNormalComment,\n  ClosingTag,\n}\n\nexport const enum TokenKind {\n  Literal,\n  OpenTag, // trim leading '<'\n  OpenTagEnd, // trim tailing '>', only could be '/' or ''\n  CloseTag, // trim leading '</' and tailing '>'\n  Whitespace, // the whitespace between attributes\n  AttrValueEq,\n  AttrValueNq,\n  AttrValueSq,\n  AttrValueDq,\n}\n\nexport interface IToken {\n  start: number;\n  end: number;\n  value: string;\n  type: TokenKind;\n}\n\nlet state: State;\nlet buffer: string;\nlet bufSize: number;\nlet sectionStart: number;\nlet index: number;\nlet tokens: IToken[];\nlet char: number;\nlet inScript: boolean;\nlet inStyle: boolean;\nlet offset: number;\n\nfunction makeCodePoints(input: string) {\n  return {\n    lower: input\n      .toLowerCase()\n      .split('')\n      .map((c) => c.charCodeAt(0)),\n    upper: input\n      .toUpperCase()\n      .split('')\n      .map((c) => c.charCodeAt(0)),\n    length: input.length,\n  };\n}\n\nconst doctype = makeCodePoints('!doctype');\nconst style = makeCodePoints('style');\nconst script = makeCodePoints('script');\n\nconst enum Chars {\n  _S = 32, // ' '\n  _N = 10, // \\n\n  _T = 9, // \\t\n  _R = 13, // \\r\n  _F = 12, // \\f\n  Lt = 60, // <\n  Ep = 33, // !\n  Cl = 45, // -\n  Sl = 47, // /\n  Gt = 62, // >\n  Qm = 63, // ?\n  La = 97, // a\n  Lz = 122, // z\n  Ua = 65, // A\n  Uz = 90, // Z\n  Eq = 61, // =\n  Sq = 39, // '\n  Dq = 34, // \"\n  Ld = 100, // d\n  Ud = 68, //D\n}\n\nfunction isWhiteSpace() {\n  return (\n    char === Chars._S ||\n    char === Chars._N ||\n    char === Chars._T ||\n    char === Chars._T ||\n    char === Chars._R ||\n    char === Chars._F\n  );\n}\n\nfunction init(input: string) {\n  state = State.Literal;\n  buffer = input;\n  bufSize = input.length;\n  sectionStart = 0;\n  index = 0;\n  tokens = [];\n  inScript = false;\n  inStyle = false;\n  offset = 0;\n}\n\nexport function tokenize(input: string): IToken[] {\n  init(input);\n  while (index < bufSize) {\n    char = buffer.charCodeAt(index);\n    switch (state) {\n      case State.Literal:\n        parseLiteral();\n        break;\n      case State.BeforeOpenTag:\n        parseBeforeOpenTag();\n        break;\n      case State.OpeningTag:\n        parseOpeningTag();\n        break;\n      case State.AfterOpenTag:\n        parseAfterOpenTag();\n        break;\n      case State.InValueNq:\n        parseInValueNq();\n        break;\n      case State.InValueSq:\n        parseInValueSq();\n        break;\n      case State.InValueDq:\n        parseInValueDq();\n        break;\n      case State.ClosingOpenTag:\n        parseClosingOpenTag();\n        break;\n      case State.OpeningSpecial:\n        parseOpeningSpecial();\n        break;\n      case State.OpeningDoctype:\n        parseOpeningDoctype();\n        break;\n      case State.OpeningNormalComment:\n        parseOpeningNormalComment();\n        break;\n      case State.InNormalComment:\n        parseNormalComment();\n        break;\n      case State.InShortComment:\n        parseShortComment();\n        break;\n      case State.ClosingNormalComment:\n        parseClosingNormalComment();\n        break;\n      case State.ClosingTag:\n        parseClosingTag();\n        break;\n      default:\n        unexpected();\n        break;\n    }\n    index++;\n  }\n  switch (state) {\n    case State.Literal:\n    case State.BeforeOpenTag:\n    case State.InValueNq:\n    case State.InValueSq:\n    case State.InValueDq:\n    case State.ClosingOpenTag:\n    case State.InNormalComment:\n    case State.InShortComment:\n    case State.ClosingNormalComment:\n      emitToken(TokenKind.Literal);\n      break;\n    case State.OpeningTag:\n      emitToken(TokenKind.OpenTag);\n      break;\n    case State.AfterOpenTag:\n      break;\n    case State.OpeningSpecial:\n      emitToken(TokenKind.OpenTag, State.InShortComment);\n      break;\n    case State.OpeningDoctype:\n      if (index - sectionStart === doctype.length) {\n        emitToken(TokenKind.OpenTag);\n      } else {\n        emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n        emitToken(TokenKind.Literal);\n      }\n      break;\n    case State.OpeningNormalComment:\n      if (index - sectionStart === 2) {\n        emitToken(TokenKind.OpenTag);\n      } else {\n        emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n        emitToken(TokenKind.Literal);\n      }\n      break;\n    case State.ClosingTag:\n      emitToken(TokenKind.CloseTag);\n      break;\n    default:\n      break;\n  }\n  const _tokens = tokens;\n  init('');\n  return _tokens;\n}\n\nfunction emitToken(kind: TokenKind, newState = state, end = index) {\n  let value = buffer.substring(sectionStart, end);\n  if (kind === TokenKind.OpenTag || kind === TokenKind.CloseTag) {\n    value = value.toLowerCase();\n  }\n  if (kind === TokenKind.OpenTag) {\n    if (value === 'script') {\n      inScript = true;\n    } else if (value === 'style') {\n      inStyle = true;\n    }\n  }\n  if (kind === TokenKind.CloseTag) {\n    inScript = inStyle = false;\n  }\n  if (!((kind === TokenKind.Literal || kind === TokenKind.Whitespace) && end === sectionStart)) {\n    // empty literal should be ignored\n    tokens.push({ type: kind, start: sectionStart, end, value });\n  }\n  if (kind === TokenKind.OpenTagEnd || kind === TokenKind.CloseTag) {\n    sectionStart = end + 1;\n    state = State.Literal;\n  } else {\n    sectionStart = end;\n    state = newState;\n  }\n}\n\nfunction parseLiteral() {\n  if (char === Chars.Lt) {\n    // <\n    emitToken(TokenKind.Literal, State.BeforeOpenTag);\n  }\n}\n\nfunction parseBeforeOpenTag() {\n  if (inScript || inStyle) {\n    if (char === Chars.Sl) {\n      state = State.ClosingTag;\n      sectionStart = index + 1;\n    } else {\n      state = State.Literal;\n    }\n    return;\n  }\n  if ((char >= Chars.La && char <= Chars.Lz) || (char >= Chars.Ua && char <= Chars.Uz)) {\n    // <d\n    state = State.OpeningTag;\n    sectionStart = index;\n  } else if (char === Chars.Sl) {\n    // </\n    state = State.ClosingTag;\n    sectionStart = index + 1;\n  } else if (char === Chars.Lt) {\n    // <<\n    emitToken(TokenKind.Literal);\n  } else if (char === Chars.Ep) {\n    // <!\n    state = State.OpeningSpecial;\n    sectionStart = index;\n  } else if (char === Chars.Qm) {\n    // <?\n    // treat as short comment\n    sectionStart = index;\n    emitToken(TokenKind.OpenTag, State.InShortComment);\n  } else {\n    // <>\n    // any other chars covert to normal state\n    state = State.Literal;\n  }\n}\n\nfunction parseOpeningTag() {\n  if (isWhiteSpace()) {\n    // <div ...\n    emitToken(TokenKind.OpenTag, State.AfterOpenTag);\n  } else if (char === Chars.Gt) {\n    // <div>\n    emitToken(TokenKind.OpenTag);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div/\n    emitToken(TokenKind.OpenTag, State.ClosingOpenTag);\n  }\n}\n\nfunction parseAfterOpenTag() {\n  if (char === Chars.Gt) {\n    // <div >\n    emitToken(TokenKind.Whitespace);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div /\n    emitToken(TokenKind.Whitespace, State.ClosingOpenTag);\n  } else if (char === Chars.Eq) {\n    // <div ...=...\n    emitToken(TokenKind.Whitespace);\n    emitToken(TokenKind.AttrValueEq, void 0, index + 1);\n  } else if (char === Chars.Sq) {\n    // <div ...'...\n    emitToken(TokenKind.Whitespace, State.InValueSq);\n  } else if (char === Chars.Dq) {\n    // <div ...\"...\n    emitToken(TokenKind.Whitespace, State.InValueDq);\n  } else if (!isWhiteSpace()) {\n    // <div ...name...\n    emitToken(TokenKind.Whitespace, State.InValueNq);\n  }\n}\n\nfunction parseInValueNq() {\n  if (char === Chars.Gt) {\n    // <div xxx>\n    emitToken(TokenKind.AttrValueNq);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div xxx/\n    emitToken(TokenKind.AttrValueNq, State.ClosingOpenTag);\n  } else if (char === Chars.Eq) {\n    // <div xxx=\n    emitToken(TokenKind.AttrValueNq);\n    emitToken(TokenKind.AttrValueEq, State.AfterOpenTag, index + 1);\n  } else if (isWhiteSpace()) {\n    // <div xxx ...\n    emitToken(TokenKind.AttrValueNq, State.AfterOpenTag);\n  }\n}\n\nfunction parseInValueSq() {\n  if (char === Chars.Sq) {\n    // <div 'xxx'\n    emitToken(TokenKind.AttrValueSq, State.AfterOpenTag, index + 1);\n  }\n}\n\nfunction parseInValueDq() {\n  if (char === Chars.Dq) {\n    // <div \"xxx\", problem same to Sq\n    emitToken(TokenKind.AttrValueDq, State.AfterOpenTag, index + 1);\n  }\n}\n\nfunction parseClosingOpenTag() {\n  if (char === Chars.Gt) {\n    // <div />\n    emitToken(TokenKind.OpenTagEnd);\n  } else {\n    // <div /...>\n    emitToken(TokenKind.AttrValueNq, State.AfterOpenTag);\n    parseAfterOpenTag();\n  }\n}\n\nfunction parseOpeningSpecial() {\n  switch (char) {\n    case Chars.Cl: // <!-\n      state = State.OpeningNormalComment;\n      break;\n    case Chars.Ld: // <!d\n    case Chars.Ud: // <!D\n      state = State.OpeningDoctype;\n      break;\n    default:\n      emitToken(TokenKind.OpenTag, State.InShortComment);\n      break;\n  }\n}\n\nfunction parseOpeningDoctype() {\n  offset = index - sectionStart;\n  if (offset === doctype.length) {\n    // <!d, <!d , start: 0, index: 2\n    if (isWhiteSpace()) {\n      emitToken(TokenKind.OpenTag, State.AfterOpenTag);\n    } else {\n      unexpected();\n    }\n  } else if (char === Chars.Gt) {\n    // <!DOCT>\n    emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n    emitToken(TokenKind.Literal);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (doctype.lower[offset] !== char && doctype.upper[offset] !== char) {\n    // <!DOCX...\n    emitToken(TokenKind.OpenTag, State.InShortComment, sectionStart + 1);\n  }\n}\n\nfunction parseOpeningNormalComment() {\n  if (char === Chars.Cl) {\n    // <!--\n    emitToken(TokenKind.OpenTag, State.InNormalComment, index + 1);\n  } else {\n    emitToken(TokenKind.OpenTag, State.InShortComment, sectionStart + 1);\n  }\n}\n\nfunction parseNormalComment() {\n  if (char === Chars.Cl) {\n    // <!-- ... -\n    emitToken(TokenKind.Literal, State.ClosingNormalComment);\n  }\n}\n\nfunction parseShortComment() {\n  if (char === Chars.Gt) {\n    // <! ... >\n    emitToken(TokenKind.Literal);\n    emitToken(TokenKind.OpenTagEnd);\n  }\n}\n\nfunction parseClosingNormalComment() {\n  offset = index - sectionStart;\n  if (offset === 2) {\n    if (char === Chars.Gt) {\n      // <!-- xxx -->\n      emitToken(TokenKind.OpenTagEnd);\n    } else if (char === Chars.Cl) {\n      // <!-- xxx ---\n      emitToken(TokenKind.Literal, void 0, sectionStart + 1);\n    } else {\n      // <!-- xxx --x\n      state = State.InNormalComment;\n    }\n  } else if (char !== Chars.Cl) {\n    // <!-- xxx - ...\n    state = State.InNormalComment;\n  }\n}\n\nfunction parseClosingTag() {\n  offset = index - sectionStart;\n  if (inStyle) {\n    if (char === Chars.Lt) {\n      sectionStart -= 2;\n      emitToken(TokenKind.Literal, State.BeforeOpenTag);\n    } else if (offset < style.length) {\n      if (style.lower[offset] !== char && style.upper[offset] !== char) {\n        sectionStart -= 2;\n        state = State.Literal;\n      }\n    } else if (char === Chars.Gt) {\n      emitToken(TokenKind.CloseTag);\n    } else if (!isWhiteSpace()) {\n      sectionStart -= 2;\n      state = State.Literal;\n    }\n  } else if (inScript) {\n    if (char === Chars.Lt) {\n      sectionStart -= 2;\n      emitToken(TokenKind.Literal, State.BeforeOpenTag);\n    } else if (offset < script.length) {\n      if (script.lower[offset] !== char && script.upper[offset] !== char) {\n        sectionStart -= 2;\n        state = State.Literal;\n      }\n    } else if (char === Chars.Gt) {\n      emitToken(TokenKind.CloseTag);\n    } else if (!isWhiteSpace()) {\n      sectionStart -= 2;\n      state = State.Literal;\n    }\n  } else if (char === Chars.Gt) {\n    // </ xxx >\n    emitToken(TokenKind.CloseTag);\n  }\n}\n\nfunction unexpected() {\n  throw new SyntaxError(\n    `Unexpected token \"${buffer.charAt(index)}\" at ${index} when parse ${state}`,\n  );\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 15:56:14\n * @version 1.0.0\n * @desc config.ts\n */\n\nfunction createMap<T>(keys: string, value: T): Record<string, T> {\n  return keys.split(',').reduce((pre, now) => {\n    pre[now] = value;\n    return pre;\n  }, Object.create(null));\n}\n\nexport const selfCloseTags = createMap<true>(\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr,!doctype,,!,!--',\n  true,\n);\n\nexport const noNestedTags = createMap<true>('li,option,select,textarea', true);\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc parse.ts\n */\n\nimport { noNestedTags, selfCloseTags } from './config';\nimport { IToken, tokenize, TokenKind } from './tokenize';\nimport { IAttribute, IAttributeValue, INode, ITag, IText, SyntaxKind } from './types';\nimport { getLineRanges, getPosition } from './utils';\nimport { walk } from './walk';\n\ninterface IContext {\n  parent: IContext | undefined;\n  tag: ITag;\n}\n\nexport interface ParseOptions {\n  // create tag's attributes map\n  // if true, will set ITag.attributeMap property\n  // as a `Record<string, IAttribute>`\n  setAttributeMap: boolean;\n}\n\nlet index: number;\nlet count: number;\nlet tokens: IToken[];\nlet tagChain: IContext | undefined;\nlet nodes: INode[];\nlet token: IToken;\nlet node: IText | undefined;\nlet buffer: string;\nlet lines: number[] | undefined;\nlet parseOptions: ParseOptions | undefined;\n\nfunction init(input?: string, options?: ParseOptions) {\n  if (input === void 0) {\n    count = 0;\n    tokens.length = 0;\n    buffer = '';\n  } else {\n    tokens = tokenize(input);\n    count = tokens.length;\n    buffer = input;\n  }\n  index = 0;\n  tagChain = void 0;\n  nodes = [];\n  token = void 0 as any;\n  node = void 0;\n  lines = void 0;\n  parseOptions = options;\n}\n\nfunction pushNode(_node: ITag | IText) {\n  if (!tagChain) {\n    nodes.push(_node);\n  } else if (\n    _node.type === SyntaxKind.Tag &&\n    _node.name === tagChain.tag.name &&\n    noNestedTags[_node.name]\n  ) {\n    tagChain = tagChain.parent;\n    pushNode(_node);\n  } else if (tagChain.tag.body) {\n    tagChain.tag.end = _node.end;\n    tagChain.tag.body.push(_node);\n  }\n}\n\nfunction pushTagChain(tag: ITag) {\n  tagChain = { parent: tagChain, tag: tag };\n  node = void 0;\n}\n\nfunction createLiteral(start = token.start, end = token.end, value = token.value): IText {\n  return { start, end, value, type: SyntaxKind.Text };\n}\n\nfunction createTag(): ITag {\n  return {\n    start: token.start - 1, // include <\n    end: token.end,\n    type: SyntaxKind.Tag,\n    open: createLiteral(token.start - 1), // not finished\n    name: token.value,\n    rawName: buffer.substring(token.start, token.end),\n    attributes: [],\n    attributeMap: void 0,\n    body: null,\n    close: null,\n  };\n}\n\nfunction createAttribute(): IAttribute {\n  return {\n    start: token.start,\n    end: token.end,\n    name: createLiteral(),\n    value: void 0,\n  };\n}\n\nfunction createAttributeValue(): IAttributeValue {\n  return {\n    start: token.start,\n    end: token.end,\n    value:\n      token.type === TokenKind.AttrValueNq\n        ? token.value\n        : token.value.substr(1, token.value.length - 2),\n    quote:\n      token.type === TokenKind.AttrValueNq\n        ? void 0\n        : token.type === TokenKind.AttrValueSq\n        ? \"'\"\n        : '\"',\n  };\n}\n\nfunction appendLiteral(_node: IText | IAttributeValue = node as IText) {\n  _node.value += token.value;\n  _node.end = token.end;\n}\n\nfunction unexpected() {\n  if (lines === void 0) {\n    lines = getLineRanges(buffer);\n  }\n  const [line, column] = getPosition(lines, token.start);\n  throw new Error(\n    `Unexpected token \"${token.value}(${token.type})\" at [${line},${column}]` +\n      (tagChain ? ` when parsing tag: ${JSON.stringify(tagChain.tag.name)}.` : ''),\n  );\n}\n\nfunction buildAttributeMap(tag: ITag) {\n  tag.attributeMap = {};\n  for (const attr of tag.attributes) {\n    tag.attributeMap[attr.name.value] = attr;\n  }\n}\n\nconst enum OpenTagState {\n  BeforeAttr,\n  InName,\n  AfterName,\n  AfterEqual,\n  InValue,\n}\n\nfunction parseOpenTag() {\n  let state = OpenTagState.BeforeAttr;\n\n  let attr: IAttribute = void 0 as any;\n\n  const tag = createTag();\n  pushNode(tag);\n  if (tag.name === '' || tag.name === '!' || tag.name === '!--') {\n    tag.open.value = '<' + tag.open.value;\n    if (index === count) {\n      return;\n    } else {\n      token = tokens[++index];\n      if (token.type !== TokenKind.OpenTagEnd) {\n        node = createLiteral();\n        tag.body = [node];\n        while (++index < count) {\n          token = tokens[index];\n          if (token.type === TokenKind.OpenTagEnd) {\n            node = void 0;\n            break;\n          }\n          appendLiteral();\n        }\n      }\n      tag.close = createLiteral(token.start, token.end + 1, `${token.value}>`);\n      tag.end = tag.close.end;\n    }\n    return;\n  }\n  while (++index < count) {\n    token = tokens[index];\n    if (token.type === TokenKind.OpenTagEnd) {\n      tag.end = tag.open.end = token.end + 1;\n      tag.open.value = buffer.substring(tag.open.start, tag.open.end);\n      if (token.value === '' && !selfCloseTags[tag.name]) {\n        tag.body = [];\n        pushTagChain(tag);\n      } else {\n        tag.body = void 0;\n      }\n      break;\n    } else if (state === OpenTagState.BeforeAttr) {\n      if (token.type !== TokenKind.Whitespace) {\n        attr = createAttribute();\n        state = OpenTagState.InName;\n        tag.attributes.push(attr);\n      }\n    } else if (state === OpenTagState.InName) {\n      if (token.type === TokenKind.Whitespace) {\n        state = OpenTagState.AfterName;\n      } else if (token.type === TokenKind.AttrValueEq) {\n        state = OpenTagState.AfterEqual;\n      } else {\n        appendLiteral(attr.name);\n      }\n    } else if (state === OpenTagState.AfterName) {\n      if (token.type !== TokenKind.Whitespace) {\n        if (token.type === TokenKind.AttrValueEq) {\n          state = OpenTagState.AfterEqual;\n        } else {\n          attr = createAttribute();\n          state = OpenTagState.InName;\n          tag.attributes.push(attr);\n        }\n      }\n    } else if (state === OpenTagState.AfterEqual) {\n      if (token.type !== TokenKind.Whitespace) {\n        attr.value = createAttributeValue();\n        if (token.type === TokenKind.AttrValueNq) {\n          state = OpenTagState.InValue;\n        } else {\n          attr.end = attr.value.end;\n          state = OpenTagState.BeforeAttr;\n        }\n      }\n    } else {\n      if (token.type === TokenKind.Whitespace) {\n        attr.end = attr.value!.end;\n        state = OpenTagState.BeforeAttr;\n      } else {\n        appendLiteral(attr.value);\n      }\n    }\n  }\n}\n\nfunction parseCloseTag() {\n  let _context = tagChain;\n  while (true) {\n    if (!_context || token.value.trim() === _context.tag.name) {\n      break;\n    }\n    _context = _context.parent;\n  }\n  if (!_context) {\n    return;\n  }\n  _context.tag.close = createLiteral(\n    token.start - 2,\n    token.end + 1,\n    buffer.substring(token.start - 2, token.end + 1),\n  );\n  _context.tag.end = _context.tag.close.end;\n  _context = _context.parent;\n  tagChain = _context;\n}\n\nexport function parse(input: string, options?: ParseOptions): INode[] {\n  init(input, {\n    setAttributeMap: false,\n    ...options,\n  } as ParseOptions);\n  while (index < count) {\n    token = tokens[index];\n    switch (token.type) {\n      case TokenKind.Literal:\n        if (!node) {\n          node = createLiteral();\n          pushNode(node);\n        } else {\n          appendLiteral(node);\n        }\n        break;\n      case TokenKind.OpenTag:\n        node = void 0;\n        parseOpenTag();\n        break;\n      case TokenKind.CloseTag:\n        node = void 0;\n        parseCloseTag();\n        break;\n      default:\n        unexpected();\n        break;\n    }\n    index++;\n  }\n  const _nodes = nodes;\n  if (parseOptions?.setAttributeMap) {\n    walk(_nodes, {\n      enter(node: IText | ITag): void {\n        if (node.type === SyntaxKind.Tag) {\n          buildAttributeMap(node);\n        }\n      },\n    });\n  }\n  init();\n  return _nodes;\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc walk.ts\n */\n\nimport { INode, SyntaxKind } from './types';\n\nexport interface WalkOptions {\n  enter?(node: INode, parent: INode | undefined, index: number): void;\n  leave?(node: INode, parent: INode | undefined, index: number): void;\n}\n\nfunction visit(node: INode, parent: INode | undefined, index: number, options: WalkOptions) {\n  options.enter && options.enter(node, parent, index);\n  if (node.type === SyntaxKind.Tag && Array.isArray(node.body)) {\n    for (let i = 0; i < node.body.length; i++) {\n      visit(node.body[i], node, i, options);\n    }\n  }\n  options.leave && options.leave(node, parent, index);\n}\n\nexport function walk(ast: INode[], options: WalkOptions) {\n  for (let i = 0; i < ast.length; i++) {\n    visit(ast[i], void 0, i, options);\n  }\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-20 21:41:39\n * @version 1.0.0\n * @desc utils.ts\n */\n\nexport function getLineRanges(input: string) {\n  return input.split('\\n').reduce(\n    (arr, line) => {\n      arr.push(line.length + 1 + arr[arr.length - 1]);\n      return arr;\n    },\n    [0],\n  );\n}\n\nexport function getPosition(ranges: number[], offset: number): [number, number] {\n  let line = NaN;\n  let column = NaN;\n  for (let i = 1; i < ranges.length; i++) {\n    if (ranges[i] > offset) {\n      line = i;\n      column = offset - ranges[i - 1] + 1;\n      break;\n    }\n  }\n  return [line, column];\n}\n","/*\n * @since 2020-09-09 22:53:14\n * @author acrazing <joking.young@gmail.com>\n */\n\nimport { selfCloseTags } from './config';\nimport { parse } from './parse';\nimport { INode, SyntaxKind } from './types';\n\nexport interface SafeHtmlOptions {\n  allowedTags: string[];\n  allowedAttrs: string[];\n  tagAllowedAttrs: Record<string, string[]>;\n  allowedUrl: RegExp;\n}\n\nexport const safeHtmlDefaultOptions: SafeHtmlOptions = {\n  allowedTags: [\n    'a',\n    'abbr',\n    'address',\n    'area',\n    'article',\n    'aside',\n    'b',\n    'bdi',\n    'bdo',\n    'big',\n    'blockquote',\n    'br',\n    'button',\n    'caption',\n    'cite',\n    'code',\n    'col',\n    'colgroup',\n    'data',\n    'dd',\n    'del',\n    'dfn',\n    'div',\n    'dl',\n    'dt',\n    'em',\n    'figcaption',\n    'figure',\n    'footer',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'header',\n    'hgroup',\n    'hr',\n    'i',\n    'img',\n    'ins',\n    'kbd',\n    'label',\n    'li',\n    'main',\n    'map',\n    'ol',\n    'p',\n    'picture',\n    'pre',\n    'q',\n    'rp',\n    'rt',\n    'ruby',\n    's',\n    'samp',\n    'section',\n    'small',\n    'span',\n    'strong',\n    'sub',\n    'summary',\n    'sup',\n    'table',\n    'tbody',\n    'td',\n    'tfoot',\n    'th',\n    'thead',\n    'time',\n    'tr',\n    'u',\n    'ul',\n    'var',\n    'wbr',\n  ],\n  allowedAttrs: ['style'],\n  tagAllowedAttrs: {\n    a: ['href', 'target'],\n    img: ['src'],\n    td: ['rowspan', 'colspan'],\n    th: ['rowspan', 'colspan'],\n    time: ['datetime'],\n    colgroup: ['span'],\n    col: ['span'],\n  },\n  allowedUrl: /^(?:mailto|tel|https?|ftp|[^:]*[^a-z0-9.+-][^:]*):|^[^:]*$/i,\n};\n\nexport function safeHtml(input: string, options: Partial<SafeHtmlOptions> = {}): string {\n  const config: SafeHtmlOptions = {\n    ...safeHtmlDefaultOptions,\n    ...options,\n    tagAllowedAttrs: {\n      ...safeHtmlDefaultOptions.tagAllowedAttrs,\n      ...options.tagAllowedAttrs,\n    },\n  };\n  const ast = parse(input);\n  return stringify(ast, config, input);\n}\n\nfunction stringify(ast: INode[], config: SafeHtmlOptions, input: string): string {\n  return ast\n    .map((node) => {\n      if (node.type === SyntaxKind.Text) {\n        return node.value;\n      }\n      if (config.allowedTags.indexOf(node.name) === -1) {\n        return '';\n      }\n      if (selfCloseTags[node.name]) {\n        if (node.body !== void 0) {\n          throw new Error(`self closed tag \"${node.name}\" should not have body`);\n        }\n      } else {\n        if (!node.body || !node.close) {\n          throw new Error(`tag \"${node.name}\" should have body and close`);\n        }\n      }\n      const attrs = node.attributes\n        .filter((a) => {\n          if (\n            config.allowedAttrs.indexOf(a.name.value) > -1 ||\n            config.tagAllowedAttrs[node.name]?.indexOf(a.name.value) > -1\n          ) {\n            if (!a.value) {\n              return true;\n            }\n            if (a.name.value !== 'src' && a.name.value !== 'href') {\n              return true;\n            }\n            if (config.allowedUrl.test(a.value.value)) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        })\n        .map((a) => input.substring(a.start, a.end))\n        .join(' ');\n      const head = '<' + node.rawName + (attrs ? ' ' + attrs : '') + '>';\n      if (!node.body) {\n        return head;\n      }\n      return head + stringify(node.body, config, input) + `</${node.rawName}>`;\n    })\n    .join('');\n}\n"],"names":["SyntaxKind","state","buffer","bufSize","sectionStart","index","tokens","char","inScript","inStyle","offset","makeCodePoints","input","lower","toLowerCase","split","map","c","charCodeAt","upper","toUpperCase","length","doctype","style","script","isWhiteSpace","init","tokenize","parseLiteral","parseBeforeOpenTag","parseOpeningTag","parseAfterOpenTag","parseInValueNq","parseInValueSq","parseInValueDq","parseClosingOpenTag","parseOpeningSpecial","parseOpeningDoctype","parseOpeningNormalComment","parseNormalComment","parseShortComment","parseClosingNormalComment","parseClosingTag","unexpected","emitToken","_tokens","kind","newState","end","value","substring","push","type","start","SyntaxError","charAt","createMap","keys","reduce","pre","now","Object","create","count","tagChain","nodes","token","node","lines","parseOptions","selfCloseTags","noNestedTags","visit","parent","options","enter","Tag","Array","isArray","body","i","leave","walk","ast","pushNode","_node","name","tag","pushTagChain","createLiteral","Text","createAttribute","appendLiteral","arr","line","_a","__read","ranges","NaN","column","getPosition","Error","JSON","stringify","buildAttributeMap","attributeMap","_b","__values","attributes","attr","parseOpenTag","open","rawName","close","substr","quote","parseCloseTag","_context","trim","parse","__assign","setAttributeMap","_nodes","safeHtmlDefaultOptions","allowedTags","allowedAttrs","tagAllowedAttrs","a","img","td","th","time","colgroup","col","allowedUrl","config","indexOf","attrs","filter","test","join","head"],"mappings":"mPAUA,IAAYA,ECqCRC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAEJ,SAASC,EAAeC,GACtB,MAAO,CACLC,MAAOD,EACJE,cACAC,MAAM,IACNC,KAAI,SAACC,GAAM,OAAAA,EAAEC,WAAW,MAC3BC,MAAOP,EACJQ,cACAL,MAAM,IACNC,KAAI,SAACC,GAAM,OAAAA,EAAEC,WAAW,MAC3BG,OAAQT,EAAMS,6BD1DNrB,EAAAA,eAAAA,8BAEVA,YC4DF,IAAMsB,EAAUX,EAAe,YACzBY,EAAQZ,EAAe,SACvBa,EAASb,EAAe,UAyB9B,SAASc,IACP,YACElB,QACAA,OACAA,OACAA,QACAA,QACAA,EAIJ,SAASmB,EAAKd,GACZX,IACAC,EAASU,EACTT,EAAUS,EAAMS,OAChBjB,EAAe,EACfC,EAAQ,EACRC,EAAS,GACTE,GAAW,EACXC,GAAU,EACVC,EAAS,WAGKiB,EAASf,GAEvB,IADAc,EAAKd,GACEP,EAAQF,GAAS,CAEtB,OADAI,EAAOL,EAAOgB,WAAWb,GACjBJ,GACN,OACE2B,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,OACEC,IACA,MACF,QACEC,IACA,MACF,QACEC,IACA,MACF,QACEC,IACA,MACF,QACEC,IACA,MACF,QACEC,IACA,MACF,QACEC,IAGJtC,IAEF,OAAQJ,GACN,OACA,OACA,OACA,OACA,OACA,OACA,QACA,QACA,QACE2C,KACA,MACF,OACEA,KACA,MACF,OACE,MACF,OACEA,QACA,MACF,OACMvC,EAAQD,IAAiBkB,EAAQD,OACnCuB,MAEAA,SAA6B,EAAQxC,EAAe,GACpDwC,MAEF,MACF,QACMvC,EAAQD,GAAiB,EAC3BwC,MAEAA,SAA6B,EAAQxC,EAAe,GACpDwC,MAEF,MACF,QACEA,KAKJ,IAAMC,EAAUvC,EAEhB,OADAoB,EAAK,IACEmB,EAGT,SAASD,EAAUE,EAAiBC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"}