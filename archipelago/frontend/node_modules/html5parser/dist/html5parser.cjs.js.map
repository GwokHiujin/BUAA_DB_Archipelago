{"version":3,"file":"html5parser.cjs.js","sources":["../src/types.ts","../src/tokenize.ts","../src/config.ts","../src/utils.ts","../src/walk.ts","../src/parse.ts","../src/safeHtml.ts"],"sourcesContent":["/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-18 15:17:51\n * @version 1.0.0\n * @desc types.ts\n */\n\nexport enum SyntaxKind {\n  Text = 'Text',\n  Tag = 'Tag',\n}\n\nexport interface IBaseNode {\n  start: number;\n  end: number;\n}\n\nexport interface IText extends IBaseNode {\n  type: SyntaxKind.Text;\n  value: string;\n}\n\nexport interface IAttributeValue extends IBaseNode {\n  value: string;\n  quote: \"'\" | '\"' | undefined;\n}\n\nexport interface IAttribute extends IBaseNode {\n  name: IText;\n  value: IAttributeValue | undefined;\n}\n\nexport interface ITag extends IBaseNode {\n  type: SyntaxKind.Tag;\n  // original open tag, <Div id=\"id\">\n  open: IText;\n  // lower case tag name, div\n  name: string;\n  // original case tag name, Div\n  rawName: string;\n  attributes: IAttribute[];\n  // the attribute map, if `options.setAttributeMap` is `true`\n  // this will be a Record, key is the attribute name literal,\n  // value is the attribute self.\n  attributeMap: Record<string, IAttribute> | undefined;\n  body:\n    | Array<ITag | IText> // with close tag\n    | undefined // self closed\n    | null; // EOF before open tag end\n  // original close tag, </DIV >\n  close:\n    | IText // with close tag\n    | undefined // self closed\n    | null; // EOF before end or without close tag\n}\n\nexport type INode = IText | ITag;\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:29\n * @version 1.0.0\n * @desc tokenize.ts\n */\n\nconst enum State {\n  Literal,\n  BeforeOpenTag,\n  OpeningTag,\n  AfterOpenTag,\n  InValueNq,\n  InValueSq,\n  InValueDq,\n  ClosingOpenTag,\n  OpeningSpecial,\n  OpeningDoctype,\n  OpeningNormalComment,\n  InNormalComment,\n  InShortComment,\n  ClosingNormalComment,\n  ClosingTag,\n}\n\nexport const enum TokenKind {\n  Literal,\n  OpenTag, // trim leading '<'\n  OpenTagEnd, // trim tailing '>', only could be '/' or ''\n  CloseTag, // trim leading '</' and tailing '>'\n  Whitespace, // the whitespace between attributes\n  AttrValueEq,\n  AttrValueNq,\n  AttrValueSq,\n  AttrValueDq,\n}\n\nexport interface IToken {\n  start: number;\n  end: number;\n  value: string;\n  type: TokenKind;\n}\n\nlet state: State;\nlet buffer: string;\nlet bufSize: number;\nlet sectionStart: number;\nlet index: number;\nlet tokens: IToken[];\nlet char: number;\nlet inScript: boolean;\nlet inStyle: boolean;\nlet offset: number;\n\nfunction makeCodePoints(input: string) {\n  return {\n    lower: input\n      .toLowerCase()\n      .split('')\n      .map((c) => c.charCodeAt(0)),\n    upper: input\n      .toUpperCase()\n      .split('')\n      .map((c) => c.charCodeAt(0)),\n    length: input.length,\n  };\n}\n\nconst doctype = makeCodePoints('!doctype');\nconst style = makeCodePoints('style');\nconst script = makeCodePoints('script');\n\nconst enum Chars {\n  _S = 32, // ' '\n  _N = 10, // \\n\n  _T = 9, // \\t\n  _R = 13, // \\r\n  _F = 12, // \\f\n  Lt = 60, // <\n  Ep = 33, // !\n  Cl = 45, // -\n  Sl = 47, // /\n  Gt = 62, // >\n  Qm = 63, // ?\n  La = 97, // a\n  Lz = 122, // z\n  Ua = 65, // A\n  Uz = 90, // Z\n  Eq = 61, // =\n  Sq = 39, // '\n  Dq = 34, // \"\n  Ld = 100, // d\n  Ud = 68, //D\n}\n\nfunction isWhiteSpace() {\n  return (\n    char === Chars._S ||\n    char === Chars._N ||\n    char === Chars._T ||\n    char === Chars._T ||\n    char === Chars._R ||\n    char === Chars._F\n  );\n}\n\nfunction init(input: string) {\n  state = State.Literal;\n  buffer = input;\n  bufSize = input.length;\n  sectionStart = 0;\n  index = 0;\n  tokens = [];\n  inScript = false;\n  inStyle = false;\n  offset = 0;\n}\n\nexport function tokenize(input: string): IToken[] {\n  init(input);\n  while (index < bufSize) {\n    char = buffer.charCodeAt(index);\n    switch (state) {\n      case State.Literal:\n        parseLiteral();\n        break;\n      case State.BeforeOpenTag:\n        parseBeforeOpenTag();\n        break;\n      case State.OpeningTag:\n        parseOpeningTag();\n        break;\n      case State.AfterOpenTag:\n        parseAfterOpenTag();\n        break;\n      case State.InValueNq:\n        parseInValueNq();\n        break;\n      case State.InValueSq:\n        parseInValueSq();\n        break;\n      case State.InValueDq:\n        parseInValueDq();\n        break;\n      case State.ClosingOpenTag:\n        parseClosingOpenTag();\n        break;\n      case State.OpeningSpecial:\n        parseOpeningSpecial();\n        break;\n      case State.OpeningDoctype:\n        parseOpeningDoctype();\n        break;\n      case State.OpeningNormalComment:\n        parseOpeningNormalComment();\n        break;\n      case State.InNormalComment:\n        parseNormalComment();\n        break;\n      case State.InShortComment:\n        parseShortComment();\n        break;\n      case State.ClosingNormalComment:\n        parseClosingNormalComment();\n        break;\n      case State.ClosingTag:\n        parseClosingTag();\n        break;\n      default:\n        unexpected();\n        break;\n    }\n    index++;\n  }\n  switch (state) {\n    case State.Literal:\n    case State.BeforeOpenTag:\n    case State.InValueNq:\n    case State.InValueSq:\n    case State.InValueDq:\n    case State.ClosingOpenTag:\n    case State.InNormalComment:\n    case State.InShortComment:\n    case State.ClosingNormalComment:\n      emitToken(TokenKind.Literal);\n      break;\n    case State.OpeningTag:\n      emitToken(TokenKind.OpenTag);\n      break;\n    case State.AfterOpenTag:\n      break;\n    case State.OpeningSpecial:\n      emitToken(TokenKind.OpenTag, State.InShortComment);\n      break;\n    case State.OpeningDoctype:\n      if (index - sectionStart === doctype.length) {\n        emitToken(TokenKind.OpenTag);\n      } else {\n        emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n        emitToken(TokenKind.Literal);\n      }\n      break;\n    case State.OpeningNormalComment:\n      if (index - sectionStart === 2) {\n        emitToken(TokenKind.OpenTag);\n      } else {\n        emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n        emitToken(TokenKind.Literal);\n      }\n      break;\n    case State.ClosingTag:\n      emitToken(TokenKind.CloseTag);\n      break;\n    default:\n      break;\n  }\n  const _tokens = tokens;\n  init('');\n  return _tokens;\n}\n\nfunction emitToken(kind: TokenKind, newState = state, end = index) {\n  let value = buffer.substring(sectionStart, end);\n  if (kind === TokenKind.OpenTag || kind === TokenKind.CloseTag) {\n    value = value.toLowerCase();\n  }\n  if (kind === TokenKind.OpenTag) {\n    if (value === 'script') {\n      inScript = true;\n    } else if (value === 'style') {\n      inStyle = true;\n    }\n  }\n  if (kind === TokenKind.CloseTag) {\n    inScript = inStyle = false;\n  }\n  if (!((kind === TokenKind.Literal || kind === TokenKind.Whitespace) && end === sectionStart)) {\n    // empty literal should be ignored\n    tokens.push({ type: kind, start: sectionStart, end, value });\n  }\n  if (kind === TokenKind.OpenTagEnd || kind === TokenKind.CloseTag) {\n    sectionStart = end + 1;\n    state = State.Literal;\n  } else {\n    sectionStart = end;\n    state = newState;\n  }\n}\n\nfunction parseLiteral() {\n  if (char === Chars.Lt) {\n    // <\n    emitToken(TokenKind.Literal, State.BeforeOpenTag);\n  }\n}\n\nfunction parseBeforeOpenTag() {\n  if (inScript || inStyle) {\n    if (char === Chars.Sl) {\n      state = State.ClosingTag;\n      sectionStart = index + 1;\n    } else {\n      state = State.Literal;\n    }\n    return;\n  }\n  if ((char >= Chars.La && char <= Chars.Lz) || (char >= Chars.Ua && char <= Chars.Uz)) {\n    // <d\n    state = State.OpeningTag;\n    sectionStart = index;\n  } else if (char === Chars.Sl) {\n    // </\n    state = State.ClosingTag;\n    sectionStart = index + 1;\n  } else if (char === Chars.Lt) {\n    // <<\n    emitToken(TokenKind.Literal);\n  } else if (char === Chars.Ep) {\n    // <!\n    state = State.OpeningSpecial;\n    sectionStart = index;\n  } else if (char === Chars.Qm) {\n    // <?\n    // treat as short comment\n    sectionStart = index;\n    emitToken(TokenKind.OpenTag, State.InShortComment);\n  } else {\n    // <>\n    // any other chars covert to normal state\n    state = State.Literal;\n  }\n}\n\nfunction parseOpeningTag() {\n  if (isWhiteSpace()) {\n    // <div ...\n    emitToken(TokenKind.OpenTag, State.AfterOpenTag);\n  } else if (char === Chars.Gt) {\n    // <div>\n    emitToken(TokenKind.OpenTag);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div/\n    emitToken(TokenKind.OpenTag, State.ClosingOpenTag);\n  }\n}\n\nfunction parseAfterOpenTag() {\n  if (char === Chars.Gt) {\n    // <div >\n    emitToken(TokenKind.Whitespace);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div /\n    emitToken(TokenKind.Whitespace, State.ClosingOpenTag);\n  } else if (char === Chars.Eq) {\n    // <div ...=...\n    emitToken(TokenKind.Whitespace);\n    emitToken(TokenKind.AttrValueEq, void 0, index + 1);\n  } else if (char === Chars.Sq) {\n    // <div ...'...\n    emitToken(TokenKind.Whitespace, State.InValueSq);\n  } else if (char === Chars.Dq) {\n    // <div ...\"...\n    emitToken(TokenKind.Whitespace, State.InValueDq);\n  } else if (!isWhiteSpace()) {\n    // <div ...name...\n    emitToken(TokenKind.Whitespace, State.InValueNq);\n  }\n}\n\nfunction parseInValueNq() {\n  if (char === Chars.Gt) {\n    // <div xxx>\n    emitToken(TokenKind.AttrValueNq);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (char === Chars.Sl) {\n    // <div xxx/\n    emitToken(TokenKind.AttrValueNq, State.ClosingOpenTag);\n  } else if (char === Chars.Eq) {\n    // <div xxx=\n    emitToken(TokenKind.AttrValueNq);\n    emitToken(TokenKind.AttrValueEq, State.AfterOpenTag, index + 1);\n  } else if (isWhiteSpace()) {\n    // <div xxx ...\n    emitToken(TokenKind.AttrValueNq, State.AfterOpenTag);\n  }\n}\n\nfunction parseInValueSq() {\n  if (char === Chars.Sq) {\n    // <div 'xxx'\n    emitToken(TokenKind.AttrValueSq, State.AfterOpenTag, index + 1);\n  }\n}\n\nfunction parseInValueDq() {\n  if (char === Chars.Dq) {\n    // <div \"xxx\", problem same to Sq\n    emitToken(TokenKind.AttrValueDq, State.AfterOpenTag, index + 1);\n  }\n}\n\nfunction parseClosingOpenTag() {\n  if (char === Chars.Gt) {\n    // <div />\n    emitToken(TokenKind.OpenTagEnd);\n  } else {\n    // <div /...>\n    emitToken(TokenKind.AttrValueNq, State.AfterOpenTag);\n    parseAfterOpenTag();\n  }\n}\n\nfunction parseOpeningSpecial() {\n  switch (char) {\n    case Chars.Cl: // <!-\n      state = State.OpeningNormalComment;\n      break;\n    case Chars.Ld: // <!d\n    case Chars.Ud: // <!D\n      state = State.OpeningDoctype;\n      break;\n    default:\n      emitToken(TokenKind.OpenTag, State.InShortComment);\n      break;\n  }\n}\n\nfunction parseOpeningDoctype() {\n  offset = index - sectionStart;\n  if (offset === doctype.length) {\n    // <!d, <!d , start: 0, index: 2\n    if (isWhiteSpace()) {\n      emitToken(TokenKind.OpenTag, State.AfterOpenTag);\n    } else {\n      unexpected();\n    }\n  } else if (char === Chars.Gt) {\n    // <!DOCT>\n    emitToken(TokenKind.OpenTag, void 0, sectionStart + 1);\n    emitToken(TokenKind.Literal);\n    emitToken(TokenKind.OpenTagEnd);\n  } else if (doctype.lower[offset] !== char && doctype.upper[offset] !== char) {\n    // <!DOCX...\n    emitToken(TokenKind.OpenTag, State.InShortComment, sectionStart + 1);\n  }\n}\n\nfunction parseOpeningNormalComment() {\n  if (char === Chars.Cl) {\n    // <!--\n    emitToken(TokenKind.OpenTag, State.InNormalComment, index + 1);\n  } else {\n    emitToken(TokenKind.OpenTag, State.InShortComment, sectionStart + 1);\n  }\n}\n\nfunction parseNormalComment() {\n  if (char === Chars.Cl) {\n    // <!-- ... -\n    emitToken(TokenKind.Literal, State.ClosingNormalComment);\n  }\n}\n\nfunction parseShortComment() {\n  if (char === Chars.Gt) {\n    // <! ... >\n    emitToken(TokenKind.Literal);\n    emitToken(TokenKind.OpenTagEnd);\n  }\n}\n\nfunction parseClosingNormalComment() {\n  offset = index - sectionStart;\n  if (offset === 2) {\n    if (char === Chars.Gt) {\n      // <!-- xxx -->\n      emitToken(TokenKind.OpenTagEnd);\n    } else if (char === Chars.Cl) {\n      // <!-- xxx ---\n      emitToken(TokenKind.Literal, void 0, sectionStart + 1);\n    } else {\n      // <!-- xxx --x\n      state = State.InNormalComment;\n    }\n  } else if (char !== Chars.Cl) {\n    // <!-- xxx - ...\n    state = State.InNormalComment;\n  }\n}\n\nfunction parseClosingTag() {\n  offset = index - sectionStart;\n  if (inStyle) {\n    if (char === Chars.Lt) {\n      sectionStart -= 2;\n      emitToken(TokenKind.Literal, State.BeforeOpenTag);\n    } else if (offset < style.length) {\n      if (style.lower[offset] !== char && style.upper[offset] !== char) {\n        sectionStart -= 2;\n        state = State.Literal;\n      }\n    } else if (char === Chars.Gt) {\n      emitToken(TokenKind.CloseTag);\n    } else if (!isWhiteSpace()) {\n      sectionStart -= 2;\n      state = State.Literal;\n    }\n  } else if (inScript) {\n    if (char === Chars.Lt) {\n      sectionStart -= 2;\n      emitToken(TokenKind.Literal, State.BeforeOpenTag);\n    } else if (offset < script.length) {\n      if (script.lower[offset] !== char && script.upper[offset] !== char) {\n        sectionStart -= 2;\n        state = State.Literal;\n      }\n    } else if (char === Chars.Gt) {\n      emitToken(TokenKind.CloseTag);\n    } else if (!isWhiteSpace()) {\n      sectionStart -= 2;\n      state = State.Literal;\n    }\n  } else if (char === Chars.Gt) {\n    // </ xxx >\n    emitToken(TokenKind.CloseTag);\n  }\n}\n\nfunction unexpected() {\n  throw new SyntaxError(\n    `Unexpected token \"${buffer.charAt(index)}\" at ${index} when parse ${state}`,\n  );\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 15:56:14\n * @version 1.0.0\n * @desc config.ts\n */\n\nfunction createMap<T>(keys: string, value: T): Record<string, T> {\n  return keys.split(',').reduce((pre, now) => {\n    pre[now] = value;\n    return pre;\n  }, Object.create(null));\n}\n\nexport const selfCloseTags = createMap<true>(\n  'area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr,!doctype,,!,!--',\n  true,\n);\n\nexport const noNestedTags = createMap<true>('li,option,select,textarea', true);\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-20 21:41:39\n * @version 1.0.0\n * @desc utils.ts\n */\n\nexport function getLineRanges(input: string) {\n  return input.split('\\n').reduce(\n    (arr, line) => {\n      arr.push(line.length + 1 + arr[arr.length - 1]);\n      return arr;\n    },\n    [0],\n  );\n}\n\nexport function getPosition(ranges: number[], offset: number): [number, number] {\n  let line = NaN;\n  let column = NaN;\n  for (let i = 1; i < ranges.length; i++) {\n    if (ranges[i] > offset) {\n      line = i;\n      column = offset - ranges[i - 1] + 1;\n      break;\n    }\n  }\n  return [line, column];\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc walk.ts\n */\n\nimport { INode, SyntaxKind } from './types';\n\nexport interface WalkOptions {\n  enter?(node: INode, parent: INode | undefined, index: number): void;\n  leave?(node: INode, parent: INode | undefined, index: number): void;\n}\n\nfunction visit(node: INode, parent: INode | undefined, index: number, options: WalkOptions) {\n  options.enter && options.enter(node, parent, index);\n  if (node.type === SyntaxKind.Tag && Array.isArray(node.body)) {\n    for (let i = 0; i < node.body.length; i++) {\n      visit(node.body[i], node, i, options);\n    }\n  }\n  options.leave && options.leave(node, parent, index);\n}\n\nexport function walk(ast: INode[], options: WalkOptions) {\n  for (let i = 0; i < ast.length; i++) {\n    visit(ast[i], void 0, i, options);\n  }\n}\n","/*!\n *\n * Copyright 2017 - acrazing\n *\n * @author acrazing joking.young@gmail.com\n * @since 2017-08-19 00:54:46\n * @version 1.0.0\n * @desc parse.ts\n */\n\nimport { noNestedTags, selfCloseTags } from './config';\nimport { IToken, tokenize, TokenKind } from './tokenize';\nimport { IAttribute, IAttributeValue, INode, ITag, IText, SyntaxKind } from './types';\nimport { getLineRanges, getPosition } from './utils';\nimport { walk } from './walk';\n\ninterface IContext {\n  parent: IContext | undefined;\n  tag: ITag;\n}\n\nexport interface ParseOptions {\n  // create tag's attributes map\n  // if true, will set ITag.attributeMap property\n  // as a `Record<string, IAttribute>`\n  setAttributeMap: boolean;\n}\n\nlet index: number;\nlet count: number;\nlet tokens: IToken[];\nlet tagChain: IContext | undefined;\nlet nodes: INode[];\nlet token: IToken;\nlet node: IText | undefined;\nlet buffer: string;\nlet lines: number[] | undefined;\nlet parseOptions: ParseOptions | undefined;\n\nfunction init(input?: string, options?: ParseOptions) {\n  if (input === void 0) {\n    count = 0;\n    tokens.length = 0;\n    buffer = '';\n  } else {\n    tokens = tokenize(input);\n    count = tokens.length;\n    buffer = input;\n  }\n  index = 0;\n  tagChain = void 0;\n  nodes = [];\n  token = void 0 as any;\n  node = void 0;\n  lines = void 0;\n  parseOptions = options;\n}\n\nfunction pushNode(_node: ITag | IText) {\n  if (!tagChain) {\n    nodes.push(_node);\n  } else if (\n    _node.type === SyntaxKind.Tag &&\n    _node.name === tagChain.tag.name &&\n    noNestedTags[_node.name]\n  ) {\n    tagChain = tagChain.parent;\n    pushNode(_node);\n  } else if (tagChain.tag.body) {\n    tagChain.tag.end = _node.end;\n    tagChain.tag.body.push(_node);\n  }\n}\n\nfunction pushTagChain(tag: ITag) {\n  tagChain = { parent: tagChain, tag: tag };\n  node = void 0;\n}\n\nfunction createLiteral(start = token.start, end = token.end, value = token.value): IText {\n  return { start, end, value, type: SyntaxKind.Text };\n}\n\nfunction createTag(): ITag {\n  return {\n    start: token.start - 1, // include <\n    end: token.end,\n    type: SyntaxKind.Tag,\n    open: createLiteral(token.start - 1), // not finished\n    name: token.value,\n    rawName: buffer.substring(token.start, token.end),\n    attributes: [],\n    attributeMap: void 0,\n    body: null,\n    close: null,\n  };\n}\n\nfunction createAttribute(): IAttribute {\n  return {\n    start: token.start,\n    end: token.end,\n    name: createLiteral(),\n    value: void 0,\n  };\n}\n\nfunction createAttributeValue(): IAttributeValue {\n  return {\n    start: token.start,\n    end: token.end,\n    value:\n      token.type === TokenKind.AttrValueNq\n        ? token.value\n        : token.value.substr(1, token.value.length - 2),\n    quote:\n      token.type === TokenKind.AttrValueNq\n        ? void 0\n        : token.type === TokenKind.AttrValueSq\n        ? \"'\"\n        : '\"',\n  };\n}\n\nfunction appendLiteral(_node: IText | IAttributeValue = node as IText) {\n  _node.value += token.value;\n  _node.end = token.end;\n}\n\nfunction unexpected() {\n  if (lines === void 0) {\n    lines = getLineRanges(buffer);\n  }\n  const [line, column] = getPosition(lines, token.start);\n  throw new Error(\n    `Unexpected token \"${token.value}(${token.type})\" at [${line},${column}]` +\n      (tagChain ? ` when parsing tag: ${JSON.stringify(tagChain.tag.name)}.` : ''),\n  );\n}\n\nfunction buildAttributeMap(tag: ITag) {\n  tag.attributeMap = {};\n  for (const attr of tag.attributes) {\n    tag.attributeMap[attr.name.value] = attr;\n  }\n}\n\nconst enum OpenTagState {\n  BeforeAttr,\n  InName,\n  AfterName,\n  AfterEqual,\n  InValue,\n}\n\nfunction parseOpenTag() {\n  let state = OpenTagState.BeforeAttr;\n\n  let attr: IAttribute = void 0 as any;\n\n  const tag = createTag();\n  pushNode(tag);\n  if (tag.name === '' || tag.name === '!' || tag.name === '!--') {\n    tag.open.value = '<' + tag.open.value;\n    if (index === count) {\n      return;\n    } else {\n      token = tokens[++index];\n      if (token.type !== TokenKind.OpenTagEnd) {\n        node = createLiteral();\n        tag.body = [node];\n        while (++index < count) {\n          token = tokens[index];\n          if (token.type === TokenKind.OpenTagEnd) {\n            node = void 0;\n            break;\n          }\n          appendLiteral();\n        }\n      }\n      tag.close = createLiteral(token.start, token.end + 1, `${token.value}>`);\n      tag.end = tag.close.end;\n    }\n    return;\n  }\n  while (++index < count) {\n    token = tokens[index];\n    if (token.type === TokenKind.OpenTagEnd) {\n      tag.end = tag.open.end = token.end + 1;\n      tag.open.value = buffer.substring(tag.open.start, tag.open.end);\n      if (token.value === '' && !selfCloseTags[tag.name]) {\n        tag.body = [];\n        pushTagChain(tag);\n      } else {\n        tag.body = void 0;\n      }\n      break;\n    } else if (state === OpenTagState.BeforeAttr) {\n      if (token.type !== TokenKind.Whitespace) {\n        attr = createAttribute();\n        state = OpenTagState.InName;\n        tag.attributes.push(attr);\n      }\n    } else if (state === OpenTagState.InName) {\n      if (token.type === TokenKind.Whitespace) {\n        state = OpenTagState.AfterName;\n      } else if (token.type === TokenKind.AttrValueEq) {\n        state = OpenTagState.AfterEqual;\n      } else {\n        appendLiteral(attr.name);\n      }\n    } else if (state === OpenTagState.AfterName) {\n      if (token.type !== TokenKind.Whitespace) {\n        if (token.type === TokenKind.AttrValueEq) {\n          state = OpenTagState.AfterEqual;\n        } else {\n          attr = createAttribute();\n          state = OpenTagState.InName;\n          tag.attributes.push(attr);\n        }\n      }\n    } else if (state === OpenTagState.AfterEqual) {\n      if (token.type !== TokenKind.Whitespace) {\n        attr.value = createAttributeValue();\n        if (token.type === TokenKind.AttrValueNq) {\n          state = OpenTagState.InValue;\n        } else {\n          attr.end = attr.value.end;\n          state = OpenTagState.BeforeAttr;\n        }\n      }\n    } else {\n      if (token.type === TokenKind.Whitespace) {\n        attr.end = attr.value!.end;\n        state = OpenTagState.BeforeAttr;\n      } else {\n        appendLiteral(attr.value);\n      }\n    }\n  }\n}\n\nfunction parseCloseTag() {\n  let _context = tagChain;\n  while (true) {\n    if (!_context || token.value.trim() === _context.tag.name) {\n      break;\n    }\n    _context = _context.parent;\n  }\n  if (!_context) {\n    return;\n  }\n  _context.tag.close = createLiteral(\n    token.start - 2,\n    token.end + 1,\n    buffer.substring(token.start - 2, token.end + 1),\n  );\n  _context.tag.end = _context.tag.close.end;\n  _context = _context.parent;\n  tagChain = _context;\n}\n\nexport function parse(input: string, options?: ParseOptions): INode[] {\n  init(input, {\n    setAttributeMap: false,\n    ...options,\n  } as ParseOptions);\n  while (index < count) {\n    token = tokens[index];\n    switch (token.type) {\n      case TokenKind.Literal:\n        if (!node) {\n          node = createLiteral();\n          pushNode(node);\n        } else {\n          appendLiteral(node);\n        }\n        break;\n      case TokenKind.OpenTag:\n        node = void 0;\n        parseOpenTag();\n        break;\n      case TokenKind.CloseTag:\n        node = void 0;\n        parseCloseTag();\n        break;\n      default:\n        unexpected();\n        break;\n    }\n    index++;\n  }\n  const _nodes = nodes;\n  if (parseOptions?.setAttributeMap) {\n    walk(_nodes, {\n      enter(node: IText | ITag): void {\n        if (node.type === SyntaxKind.Tag) {\n          buildAttributeMap(node);\n        }\n      },\n    });\n  }\n  init();\n  return _nodes;\n}\n","/*\n * @since 2020-09-09 22:53:14\n * @author acrazing <joking.young@gmail.com>\n */\n\nimport { selfCloseTags } from './config';\nimport { parse } from './parse';\nimport { INode, SyntaxKind } from './types';\n\nexport interface SafeHtmlOptions {\n  allowedTags: string[];\n  allowedAttrs: string[];\n  tagAllowedAttrs: Record<string, string[]>;\n  allowedUrl: RegExp;\n}\n\nexport const safeHtmlDefaultOptions: SafeHtmlOptions = {\n  allowedTags: [\n    'a',\n    'abbr',\n    'address',\n    'area',\n    'article',\n    'aside',\n    'b',\n    'bdi',\n    'bdo',\n    'big',\n    'blockquote',\n    'br',\n    'button',\n    'caption',\n    'cite',\n    'code',\n    'col',\n    'colgroup',\n    'data',\n    'dd',\n    'del',\n    'dfn',\n    'div',\n    'dl',\n    'dt',\n    'em',\n    'figcaption',\n    'figure',\n    'footer',\n    'h1',\n    'h2',\n    'h3',\n    'h4',\n    'h5',\n    'h6',\n    'header',\n    'hgroup',\n    'hr',\n    'i',\n    'img',\n    'ins',\n    'kbd',\n    'label',\n    'li',\n    'main',\n    'map',\n    'ol',\n    'p',\n    'picture',\n    'pre',\n    'q',\n    'rp',\n    'rt',\n    'ruby',\n    's',\n    'samp',\n    'section',\n    'small',\n    'span',\n    'strong',\n    'sub',\n    'summary',\n    'sup',\n    'table',\n    'tbody',\n    'td',\n    'tfoot',\n    'th',\n    'thead',\n    'time',\n    'tr',\n    'u',\n    'ul',\n    'var',\n    'wbr',\n  ],\n  allowedAttrs: ['style'],\n  tagAllowedAttrs: {\n    a: ['href', 'target'],\n    img: ['src'],\n    td: ['rowspan', 'colspan'],\n    th: ['rowspan', 'colspan'],\n    time: ['datetime'],\n    colgroup: ['span'],\n    col: ['span'],\n  },\n  allowedUrl: /^(?:mailto|tel|https?|ftp|[^:]*[^a-z0-9.+-][^:]*):|^[^:]*$/i,\n};\n\nexport function safeHtml(input: string, options: Partial<SafeHtmlOptions> = {}): string {\n  const config: SafeHtmlOptions = {\n    ...safeHtmlDefaultOptions,\n    ...options,\n    tagAllowedAttrs: {\n      ...safeHtmlDefaultOptions.tagAllowedAttrs,\n      ...options.tagAllowedAttrs,\n    },\n  };\n  const ast = parse(input);\n  return stringify(ast, config, input);\n}\n\nfunction stringify(ast: INode[], config: SafeHtmlOptions, input: string): string {\n  return ast\n    .map((node) => {\n      if (node.type === SyntaxKind.Text) {\n        return node.value;\n      }\n      if (config.allowedTags.indexOf(node.name) === -1) {\n        return '';\n      }\n      if (selfCloseTags[node.name]) {\n        if (node.body !== void 0) {\n          throw new Error(`self closed tag \"${node.name}\" should not have body`);\n        }\n      } else {\n        if (!node.body || !node.close) {\n          throw new Error(`tag \"${node.name}\" should have body and close`);\n        }\n      }\n      const attrs = node.attributes\n        .filter((a) => {\n          if (\n            config.allowedAttrs.indexOf(a.name.value) > -1 ||\n            config.tagAllowedAttrs[node.name]?.indexOf(a.name.value) > -1\n          ) {\n            if (!a.value) {\n              return true;\n            }\n            if (a.name.value !== 'src' && a.name.value !== 'href') {\n              return true;\n            }\n            if (config.allowedUrl.test(a.value.value)) {\n              return true;\n            }\n            return false;\n          }\n          return false;\n        })\n        .map((a) => input.substring(a.start, a.end))\n        .join(' ');\n      const head = '<' + node.rawName + (attrs ? ' ' + attrs : '') + '>';\n      if (!node.body) {\n        return head;\n      }\n      return head + stringify(node.body, config, input) + `</${node.rawName}>`;\n    })\n    .join('');\n}\n"],"names":["SyntaxKind","buffer","index","tokens","init","unexpected","__read","__values","__assign"],"mappings":"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"}